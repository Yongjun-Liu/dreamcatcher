* 
  Microcode for all ROMS
  Least significant bits on the right
  Types of micro-instruction:         seq = 00 (next is sequential)
								   branch = 01 (next depends on branch conditions)
					   		    pre-fetch = 10 (next is fetch)
					           post-fetch = 11 (next given by IR)

CarryInMux:	00 :   0	used for SUB
			01 :   1		used for ADD
			10 :  CF		used for SBB
			11 : ~CF		used for ADC


CONTROL BITS
	HIGH-------------------------------------------------------------------------------LOW

ROM1: ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
ROM2: PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
ROM3: MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
ROM4:	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt

*

*	ROM 1     ROM 2     ROM 3     ROM 4     *

>> "fetch"
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10000001, 00001000 * PC_Out, IMMVal=0, IMMOut, ALU=1001, ALUMode=0, CarryInMux=01, MAR_Wrt, type=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 00000010, 00000000 * RD, IR_Wrt, type=seq (00) *
	00100000, 10100001, 00000001, 00001100 * PC_Out, PC_Wrt, ALU=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, type= +1(00)*
	00000011, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and next instruction on X bus. post-fetch(11)* 	

>> "swp a, b"
	00100000, 00100001, 00000000, 00101001 * TDR_Wrt, A_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00(seq) *
	00100000, 00100001, 00000000, 10011000 * A_Wrt, B_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00(seq) *
	01000010, 00000011, 00000000, 01100010 * B_Wrt, TDR_Out, (A_Out), ALU_Op=1010, ALU_Mode=1, type=10(pre-fetch) *

>> "mov a, b"
	00100010, 00100001, 00000000, 10011000 * BOut, AWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux=01, type=pre-fetch(10) *

>> "mov [b], [a]"
	00100000, 00100001, 10000000, 00101000 * MAR_Wrt, A_Out, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 00100001, 10000000, 10001000 * MAR_Wrt, B_Out, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
>> "mov [a], [b]"
	00100000, 00100001, 10000000, 10001000 * MAR_Wrt, B_Out, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 00100001, 10000000, 00101000 * MAR_Wrt, A_Out, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

>> "mov a, [a]"	
	00100000, 00100001, 10000000, 00101000 * A_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 00011000 * A_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10) *

>> "mov a, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux=01, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and MDR on X bus. * 
	00100010, 00100001, 00001000, 00011000 * A_Wrt, MDR_X_Out, IMM_Out=1, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10)*

>> "mov a, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM_Val=0, CarryInMux=01, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and MDR on X bus. * 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 00011000 * A_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10) *

>> "mov [ad8], a"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and MDR on X bus. * 
	00100000, 00100001, 00000100, 00101000 * A_Out, MDRIn_Mux=0, MDR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *	

>> "mov a, [b + imm8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10010000, 10000000 * B_Out, MDR_Y_Out, MAR_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 00011000 * A_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10) *	
	
>> "mov [b + imm8], a"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10010000, 10000000 * B_Out, MDR_Y_Out, MAR_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 00000100, 00101000 * A_Out, MDRIn_Mux=0, MDR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
>> "mov [a + imm8], b"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10010000, 00100000 * A_Out, MDR_Y_Out, MAR_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 00000100, 10001000 * B_Out, MDRIn_Mux=0, MDR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	

>> "mov [a], imm8"
	* first imm8 to MDR; PC + 1 --> PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* A to MAR *
	00100000, 00100001, 10000000, 00101000 * MAR_Wrt, A_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* MDR to [b] *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "mov [a + imm8], imm8"
	* first imm8 to MDR; PC + 1 --> PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* MDR + A to TDR *
	00100000, 00100001, 00010000, 00101001 * TDR_Wrt, MDR_Y_Out, A_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000
	* second imm8 to MDR *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* TDR to MAR *
	01000000, 00000011, 10000000, 00100010 * MAR_Wrt, TDR_Out, (A_Out), ALU_Op=1010, ALU_Mode=1, type=00 *
	* MDR to [b + imm8] *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "mov [ad8], [a + b]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* MDR to TDR *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* a to MDR *
	00100000, 00100001, 00000100, 00101000 * MDR_Wrt, A_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mdr <-- mdr + b *
	00100000, 00100001, 00010100, 10000000 * MDR_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_mode=0, CarryInMux=01, type=00 *
	* mar <-- mdr *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mdr <-- [a + b] *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* mar <-- tdr *
	01000000, 00000011, 10000000, 00100010 * MAR_Wrt, TDR_Out, (A_Out), ALU_Op=1010, ALU_Mode=1, type=00 *
	* [ad8] <-- [mdr] *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
	
>> "mov [a + b], [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* mar <-- mdr *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mdr <-- [ad8] *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR to TDR *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* a to MDR *
	00100000, 00100001, 00000100, 00101000 * MDR_Wrt, A_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mar <-- mdr + b *
	00100000, 00100001, 10010000, 10000000 * MAR_Wrt, MDR_Y_Out, B_Out, ALU_Op=1001, ALU_mode=0, CarryInMux=01, type=00 *
	* mdr <-- tdr *
	01000000, 00000011, 00000100, 00100010 * MDR_Wrt, TDR_Out, (A_Out), MDR_In_Mux=0(Z), ALU_Op=1010, ALU_Mode=1, type=00 *
	* [a + b] <-- [mdr] *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "mov a, [bp + imm8]"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add TDR (signed8) and MDR; save in MAR *		 
	00100000, 00100001, 10001000, 00000010 * MAR_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* Read & mov data to A *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 00011000 * A_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *

>> "mov a, [bp + b + imm8]"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add B *
	00100000, 00100001, 00001100, 10000000 * MDR_Wrt, B_Out, MDR_X_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* Add TDR (signed8) and MDR; save in MAR *		 
	00100000, 00100001, 10001000, 00000010 * MAR_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* Read & mov data to A *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 00011000 * A_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *

>> "mov a, [bp + a + imm8]"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add A *
	00100000, 00100001, 00001100, 00100000 * MDR_Wrt, A_Out, MDR_X_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* Add TDR (signed8) and MDR; save in MAR *		 
	00100000, 00100001, 10001000, 00000010 * MAR_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* Read & mov data to A *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 00011000 * A_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *

>> "mov [bp + imm8], a"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *

	* Add TDR (signed8) and MDR; save in MAR *		 
	00100000, 00100001, 10001000, 00000010 * MAR_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* write A *
	00100000, 00100001, 00000100, 00101000 * MDR_Wrt, MDR_In_Mux=0(Z), A_Out, IMM_Out, IMM_Val, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=00(seq) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

>> "mov [bp + b + imm8], a"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add B *
	00100000, 00100001, 00001100, 10000000 * MDR_Wrt, B_Out, MDR_X_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* Add TDR (signed8) and MDR; save in MAR *		 
	00100000, 00100001, 10001000, 00000010 * MAR_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* write A *
	00100000, 00100001, 00000100, 00101000 * MDR_Wrt, MDR_In_Mux=0(Z), A_Out, IMM_Out, IMM_Val, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=00(seq) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "mov bp, a"
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* write A to &BP *
	00100000, 00100001, 00000100, 00101000 * MDR_Wrt, MDR_In_Mux=0(Z), A_Out, IMM_Out, IMM_Val, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=00(seq) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
	
>> "mov sp, a"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* write A to &SP *
	00100000, 00100001, 00000100, 00101000 * MDR_Wrt, MDR_In_Mux=0(Z), A_Out, IMM_Out, IMM_Val, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=00(seq) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
	
>> "mov a, sp"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR to A *
	00100010, 00100001, 00001000, 00011000 * A_Wrt, MDR_X_Out, IMM_Out=1, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=10(pre) *
	

*

1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt

*

>> "mov b, a"
	00100010, 00100001, 00000000, 01101000 * AOut, BWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, type=pre-fetch(10) *

>> "mov b, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 ** Send PC to MAR *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *		    
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 ** read byte from mem and write to mdr *			    
	00100000, 10100001, 00000001, 00001100 * PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 ** increase PC by 1. *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and MDR on X bus. * 
	00100010, 00100001, 00001000, 01001000 * B_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10)** save result to B: *
							    
>> "mov b, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and MDR on X bus. * 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 01001000 * B_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10) *

>> "mov [ad8], b"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and MDR on X bus. * 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between B and MDR on X bus. * 
	00100000, 00100001, 00000100, 10001000 * B_Out, MDRIn_Mux=0, MDR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

>> "mov b, [b]"	
	00100000, 00100001, 10000000, 10001000 * B_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 01001000 * B_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10) *
	
>> "mov [b], imm8"
	* first imm8 to MDR; PC + 1 --> PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* B to MAR *
	00100000, 00100001, 10000000, 10001000 * MAR_Wrt, B_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* MDR to [b] *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "mov [b + imm8], imm8"
	* first imm8 to MDR; PC + 1 --> PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* MDR + B to TDR *
	00100000, 00100001, 00010000, 10001001 * TDR_Wrt, MDR_Y_Out, B_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000
	* second imm8 to MDR *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* TDR to MAR *
	01000000, 00000011, 10000000, 00100010 * MAR_Wrt, TDR_Out, (A_Out), ALU_Op=1010, ALU_Mode=1, type=00 *
	* MDR to [b + imm8] *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

>> "mov b, [bp + imm8]"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add TDR (signed8) and MDR; save in MAR *		 
	00100000, 00100001, 10001000, 00000010 * MAR_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* Read & mov data to B *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 01001000 * B_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *

>> "mov [bp + imm8], b"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add TDR (signed8) and MDR; save in MAR *		 
	00100000, 00100001, 10001000, 00000010 * MAR_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* write B *
	00100000, 00100001, 00000100, 10001000 * MDR_Wrt, MDR_In_Mux=0(Z), B_Out, IMM_Out, IMM_Val, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=00(seq) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
	
>> "mov bp, b"
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* write B to &BP *
	00100000, 00100001, 00000100, 10001000 * MDR_Wrt, MDR_In_Mux=0(Z), B_Out, IMM_Out, IMM_Val, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=00(seq) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
	
>> "mov sp, b"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* write B to &SP *
	00100000, 00100001, 00000100, 10001000 * MDR_Wrt, MDR_In_Mux=0(Z), B_Out, IMM_Out, IMM_Val, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=00(seq) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
	
>> "mov b, sp"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR to B *
	00100010, 00100001, 00001000, 01001000 * B_Wrt, MDR_X_Out, IMM_Out=1, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=10(pre) *
	
	
>> "mov [ad8], imm8"
	* ad8 to MDR, PC + 1 to PC*
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	* MDR to TDR *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000
	* imm8 to MDR, PC + 1 to PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* TDR to MAR *
	01000000, 00000011, 10000000, 00100010 * MAR_Wrt, TDR_Out, (A_Out), ALU_Op=1010, ALU_Mode=1, type=00 *
	* MDR to [ad8] *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *	


>> "lea a, [bp + imm8]"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add TDR (signed8) and MDR; save in A *		 
	00100010, 00100001, 00001000, 00010010 * A_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *


>> "lea a, [bp + b + imm8]"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add B *
	00100000, 00100001, 00001100, 10000000 * MDR_Wrt, B_Out, MDR_X_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* Add TDR (signed8) and MDR; save in A *		 
	00100010, 00100001, 00001000, 00010010 * A_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *


>> "lea a, [bp + a + imm8]"
	 * get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add A *
	00100000, 00100001, 00001100, 00100000 * MDR_Wrt, A_Out, MDR_X_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* Add TDR (signed8) and MDR; save in A *		 
	00100010, 00100001, 00001000, 00010010 * A_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *


>> "lea b, [bp + imm8]"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add TDR (signed8) and MDR; save in B *		 
	00100010, 00100001, 00001000, 01000010 * B_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *


>> "lea b, [bp + b + imm8]"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add B *
	00100000, 00100001, 00001100, 10000000 * MDR_Wrt, B_Out, MDR_X_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* Add TDR (signed8) and MDR; save in B *		 
	00100010, 00100001, 00001000, 01000010 * B_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *


>> "lea b, [bp + a + imm8]"
	* get SIGNED8 and save into TDR; inc PC *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=00(seq) *

	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
		
	* Add A *
	00100000, 00100001, 00001100, 00100000 * MDR_Wrt, A_Out, MDR_X_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

	* Add TDR (signed8) and MDR; save in B *		 
	00100010, 00100001, 00001000, 01000010 * B_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *

*

1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt

*


>> "inc a"
	00100010, 00111101, 00000000, 00111100 * AOut, AWrt, IMM_Out, IMM_Val=1, ALUMode=0, ALUOp=1001, CarryInMux=01, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *
	

>> "inc b"
	00100010, 00111101, 00000000, 11001100 * BOut, BWrt, IMM_Out, IMM_Val=1, ALUMode=0, ALUOp=1001, CarryInMux=01, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *

>> "inc [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM_Val=0, CarryInMux=01, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* inc MDR *
	00100000, 00111101, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, MDR_In_Mux=0(Z), IMM(1), ALUOp=1001, ALUMode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=seq(00) *
	* write *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "dec a"
	11000010, 00001100, 00000000, 00111100 * AOut, AWrt, IMM_Out, IMM_Val=1, ALUMode=0, ALUOp=0110, CarryInMux=00, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "dec b"
	11000010, 00001100, 00000000, 11001100 * BOut, BWrt, IMM_Out, IMM_Val=1, ALUMode=0, ALUOp=0110, CarryInMux=00, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "dec [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM_Val=0, CarryInMux=01, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* inc MDR *
	11000000, 00001100, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, MDR_In_Mux=0(Z), IMM(1), ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=seq(00) *
	* write *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "add sp, imm8"
	* imm8 to MDR *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* MDR to TDR *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=seq(00) *
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + TDR to MDR *
	00100000, 00111101, 00001100, 00000010 * MDR_Wrt, MDR_X_Out, TDR_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &SP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
>> "add sp, a"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + A to MDR *
	00100000, 00111101, 00010100, 00100000 * MDR_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &SP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	

>> "add sp, b"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + B to MDR *
	00100000, 00111101, 00010100, 10000000 * MDR_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &SP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "add a, sp"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + A to A *
	00100010, 00111101, 00010000, 00110000 * A_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	
	
>> "add b, sp"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + B to B *
	00100010, 00111101, 00010000, 11000000 * B_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	
	
>> "add bp, imm8"
	* imm8 to MDR *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* MDR to TDR *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=seq(00) *
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + TDR to MDR *
	00100000, 00111101, 00001100, 00000010 * MDR_Wrt, MDR_X_Out, TDR_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &BP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
>> "add bp, a"
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + A to MDR *
	00100000, 00111101, 00010100, 00100000 * MDR_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &BP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	

>> "add bp, b"
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + B to MDR *
	00100000, 00111101, 00010100, 10000000 * MDR_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &BP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "add a, bp"
	* loading 0x02 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + A to A *
	00100010, 00111101, 00010000, 00110000 * A_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	
	
>> "add b, bp"
	* loading 0x02 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + B to B *
	00100010, 00111101, 00010000, 11000000 * B_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	

	

*

1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt

*

>> "add [ad8], imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* mdr <-- [ad8] *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* tdr <-- mdr *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mdr <-- imm8 *
	00100000, 00100001, 10000001, 00001100 * PC_Out, MAR_Wrt, IMM_Out, IMM_Val=1, CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* tdr <-- tdr + mdr *
	00100000, 00111101, 00001000, 00000011 * TDR_Wrt, TDR_Out, MDR_X_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00 *
	* mdr <-- ad8 *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mar <-- mdr *
	00100000, 10100001, 00001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mdr <-- tdr *
	01000000, 00000011, 00000100, 00100010 * MDR_Wrt, TDR_Out, (A_Out), MDR_In_Mux=0, ALU_Op=1010, ALU_Mode=1, type=00 *
	* [ad8] <-- [ad8] + imm8 *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	* PC <-- PC + 2 *
	00100000, 10100001, 00000001, 00001100 * PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100010, 10100001, 00000001, 00001100 * PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	

>> "add a, a"
	00100000, 00100001, 00000000, 00101001 * TDRWrt, A_Out, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, type=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 00111101, 00000000, 00110010 * AOut, AWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "add a, b"
	00100000, 00100001, 00000000, 10001001 * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 00111101, 00000000, 00110010 * AOut, AWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "add a, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and A on X bus. * 
	00100010, 00111101, 00010000, 00110000 * A_Out, A_Wrt, MDR_Y_Out, ALUOp=1001, ALUMode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*

>> "add a, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* add to A *
	00100010, 00111101, 00010000, 00110000 * A_Wrt, MDR_Y_Out, A_Out, ALUOp=1001, ALUMode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=seq(00) *
	
	
>> "add [ad8], a"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr + a *
	00100000, 00111101, 00010100, 00100000 * MDR_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALUOp=1001, ALUMode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
	
*
1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt
*


>> "add b, b"
	00100000, 00100001, 00000000, 10001001 * B_Out, TDRWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 00111101, 00000000, 11000010 * BOut, BWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "add b, a"
	00100000, 00100001, 00000000, 00101001 * AOut, TDRWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 00111101, 00000000, 11000010 * BOut, BWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "add b, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and B on X bus. * 
	00100010, 00111101, 00010000, 11000000 * B_Out, B_Wrt, MDR_Y_Out, ALUOp=1001, ALUMode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*


>> "add b, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* add to B *
	00100010, 00111101, 00010000, 11000000 * B_Wrt, MDR_Y_Out, B_Out, ALUOp=1001, ALUMode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=seq(00) *
	

>> "add [ad8], b"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr + b *
	00100000, 00111101, 00010100, 10000000 * MDR_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALUOp=1001, ALUMode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "adc [ad8], imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* mdr <-- [ad8] *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* tdr <-- mdr *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mdr <-- imm8 *
	00100000, 00100001, 10000001, 00001100 * PC_Out, MAR_Wrt, IMM_Out, IMM_Val=1, CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* tdr <-- tdr + mdr *
	00100000, 01111101, 00001000, 00000011 * TDR_Wrt, TDR_Out, MDR_X_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=11, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00 *
	* mdr <-- ad8 *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mar <-- mdr *
	00100000, 10100001, 00001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mdr <-- tdr *
	01000000, 00000011, 00000100, 00100010 * MDR_Wrt, TDR_Out, (A_Out), MDR_In_Mux=0, ALU_Op=1010, ALU_Mode=1, type=00 *
	* [ad8] <-- [ad8] + imm8 *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	* PC <-- PC + 2 *
	00100000, 10100001, 00000001, 00001100 * PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100010, 10100001, 00000001, 00001100 * PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *


>> "adc a, a"
	00100000, 00100001, 00000000, 00101001 * A_Out, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 01111101, 00000000, 00110010 * AOut, AWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux=11, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "adc a, b"
	00100000, 00100001, 00000000, 10001001 * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 01111101, 00000000, 00110010 * AOut, AWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux=11, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "adc a, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and A on X bus. * 
	00100010, 01111101, 00010000, 00110000 * A_Out, A_Wrt, MDR_Y_Out, ALUOp=1001, ALUMode=0, CarryInMux=11, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*
	
>> "adc a, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* add to A *
	00100010, 01111101, 00010000, 00110000 * A_Wrt, MDR_Y_Out, A_Out, ALUOp=1001, ALUMode=0, CarryInMux=11, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=seq(00) *


>> "adc [ad8], a"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr + a *
	00100000, 00111101, 00010100, 00100000 * MDR_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALUOp=1001, ALUMode=0, CarryInMux=11, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "adc b, b"
	00100000, 00100001, 00000000, 10001001 * B_Out, TDRWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 01111101, 00000000, 11000010 * BOut, BWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux=11, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "adc b, a"
	00100000, 00100001, 00000000, 00101001 * AOut, TDRWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 01111101, 00000000, 11000010 * BOut, BWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux=11, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "adc b, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and B on X bus. * 
	00100010, 01111101, 00010000, 11000000 * B_Out, B_Wrt, MDR_Y_Out, ALUOp=1001, ALUMode=0, CarryInMux=11, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*
	
	
>> "adc b, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* add to B *
	00100010, 01111101, 00010000, 11000000 * B_Wrt, MDR_Y_Out, B_Out, ALUOp=1001, ALUMode=0, CarryInMux=11, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=seq(00) *
	
>> "adc [ad8], b"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr + a *
	00100000, 00111101, 00010100, 10000000 * MDR_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALUOp=1001, ALUMode=0, CarryInMux=11, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "sub [ad8], imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* mdr <-- [ad8] *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* tdr <-- mdr *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mdr <-- imm8 *
	00100000, 00100001, 10000001, 00001100 * PC_Out, MAR_Wrt, IMM_Out, IMM_Val=1, CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* tdr <-- tdr - mdr *
	11000000, 00001100, 00001000, 00000011 * TDR_Wrt, TDR_Out, MDR_X_Out, ALU_Op=0110, ALU_Mode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=00 *
	* mdr <-- ad8 *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mar <-- mdr *
	00100000, 10100001, 00001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mdr <-- tdr *
	01000000, 00000011, 00000100, 00100010 * MDR_Wrt, TDR_Out, (A_Out), MDR_In_Mux=0, ALU_Op=1010, ALU_Mode=1, type=00 *
	* [ad8] <-- [ad8] + imm8 *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	* PC <-- PC + 2 *
	00100000, 10100001, 00000001, 00001100 * PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100010, 10100001, 00000001, 00001100 * PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *


>> "sub sp, imm8"
	* imm8 to MDR *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* MDR to TDR *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=seq(00) *
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + TDR to MDR *
	00100000, 00111101, 00001100, 00000010 * MDR_Wrt, MDR_X_Out, TDR_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &SP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
>> "sub sp, a"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + A to MDR *
	00100000, 00111101, 00010100, 00100000 * MDR_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &SP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	

>> "sub sp, b"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + B to MDR *
	00100000, 00111101, 00010100, 10000000 * MDR_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &SP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "sub a, sp"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + A to A *
	00100010, 00111101, 00010000, 00110000 * A_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	
	
>> "sub b, sp"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + B to B *
	00100010, 00111101, 00010000, 11000000 * B_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=00(seq) *
	
	
>> "sub bp, imm8"
	* imm8 to MDR *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* MDR to TDR *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=seq(00) *
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR - TDR to MDR *
	11000000, 00001100, 00001100, 00000010 * MDR_Wrt, MDR_X_Out, TDR_Out, MDR_In_Mux=0, ALU_Op=0110, ALU_Mode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &BP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
>> "sub bp, a"
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* A to TDR *
	00100000, 00100001, 00000000, 00101001 * TDR_Wrt, A_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* MDR - TDR to MDR *
	11000000, 00001100, 00001100, 00000010 * MDR_Wrt, MDR_X_Out, TDR_Out, MDR_In_Mux=0, ALU_Op=0110, ALU_Mode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &BP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	

>> "sub bp, b"
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* B to TDR *
	00100000, 00100001, 00000000, 10001001 * TDR_Wrt, B_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* MDR - TDR to MDR *
	11000000, 00001100, 00001100, 00000010 * MDR_Wrt, MDR_X_Out, TDR_Out, MDR_In_Mux=0, ALU_Op=0110, ALU_Mode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=00(seq) *
	* write MDR to &BP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "sub a, bp"
	* loading 0x02 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* A - MDR to A *
	11000010, 00001100, 00010000, 00110000 * A_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALU_Op=0110, ALU_Mode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=00(seq) *
	
	
>> "sub b, bp"
	* loading 0x02 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* B - MDR to B *
	11000010, 00001100, 00010000, 11000000 * B_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALU_Op=0110, ALU_Mode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=00(seq) *


>> "sub a, b"
	00100000, 00100001, 00000000, 10001001 * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001100, 00000000, 00110010 * AOut, AWrt, TDROut, ALUMode=0, ALUOp=0110, CarryInMux1=0, CarryInMux0=0, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "sub a, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and A on X bus. * 
	11000010, 00001100, 00010000, 00110000 * A_Out, A_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*
	
	
>> "sub a, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* sub from A *
	11000010, 00001100, 00010000, 00110000 * A_Wrt, MDR_Y_Out, A_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=seq(00) *
	
>> "sub [ad8], a"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr - a *
	11000000, 00001100, 00010100, 00100000 * MDR_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "sub b, a"
	00100000, 00100001, 00000000, 00001001 * AOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001100, 00000000, 11000010 * BOut, BWrt, TDROut, ALUMode=0, ALUOp=0110, CarryInMux1=0, CarryInMux0=0, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "sub b, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and B on X bus. * 
	11000010, 00001100, 00010000, 11000000 * B_Out, B_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*


>> "sub b, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* sub from B *
	11000010, 00001100, 00010000, 11000000 * B_Wrt, MDR_Y_Out, B_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=seq(00) *
	
>> "sub [ad8], b"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr - b *
	11000000, 00001100, 00010100, 10000000 * MDR_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	

>> "sbb [ad8], imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* mdr <-- [ad8] *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* tdr <-- mdr *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mdr <-- imm8 *
	00100000, 00100001, 10000001, 00001100 * PC_Out, MAR_Wrt, IMM_Out, IMM_Val=1, CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* tdr <-- tdr - mdr *
	11000000, 01001100, 00001000, 00000011 * TDR_Wrt, TDR_Out, MDR_X_Out, ALU_Op=0110, ALU_Mode=0, CarryInMux=10, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=00 *
	* mdr <-- ad8 *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mar <-- mdr *
	00100000, 10100001, 00001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* mdr <-- tdr *
	01000000, 00000011, 00000100, 00100010 * MDR_Wrt, TDR_Out, (A_Out), MDR_In_Mux=0, ALU_Op=1010, ALU_Mode=1, type=00 *
	* [ad8] <-- [ad8] + imm8 *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	* PC <-- PC + 2 *
	00100000, 10100001, 00000001, 00001100 * PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00100010, 10100001, 00000001, 00001100 * PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *


>> "sbb a, b"
	00100000, 00100001, 00000000, 10001001 * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 01001100, 00000000, 00110010 * AOut, AWrt, TDROut, ALUMode=0, ALUOp=0110, CarryInMux=10, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *

>> "sbb a, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and A on X bus. * 
	11000010, 01001100, 00010000, 00110000 * A_Out, A_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=10, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*
	
	
>> "sbb a, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* sub from A *
	11000010, 01001100, 00010000, 00110000 * A_Wrt, MDR_Y_Out, A_Out, ALUOp=0110, ALUMode=0, CarryInMux=10, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=seq(00) *
	
>> "sbb [ad8], a"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr - a *
	11000000, 01001100, 00010100, 00100000 * MDR_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALUOp=0110, ALUMode=0, CarryInMux=10, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "sbb b, a"
	00100000, 00100001, 00000000, 00001001 * AOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 01001100, 00000000, 11000010 * BOut, BWrt, TDROut, ALUMode=0, ALUOp=0110, CarryInMux=10, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "sbb b, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and B on X bus. * 
	11000010, 01001100, 00010000, 11000000 * B_Out, B_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=10, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*
	
	
>> "sbb b, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* sub from B *
	11000010, 01001100, 00010000, 11000000 * B_Wrt, MDR_Y_Out, B_Out, ALUOp=0110, ALUMode=0, CarryInMux=10, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=seq(00) *
	
>> "sbb [ad8], b"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr - b *
	11000000, 01001100, 00010100, 10000000 * MDR_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALUOp=0110, ALUMode=0, CarryInMux=10, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

*
1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt
*


>> "test a, b"
	00100000, 00100001, 00000000, 10001001 * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	01100010, 00001011, 00000000, 00100010 * AOut, TDROut, ALUMode=1, ALUOp=1011, ZFWrt, type=pre-fetch(10) *


>> "test a, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	01100010, 00001011, 00010000, 00100000 * A_Out, MDR_Y_Out, ALUOp=1011, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*


>> "test b, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	01100010, 00001011, 00010000, 10000000 * B_Out, MDR_Y_Out, ALUOp=1011, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*


>> "and a, b"
	00100000, 00100001, 00000000, 10001001 * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	01100010, 00001011, 00000000, 00110010 * AOut, AWrt, TDROut, ALUMode=1, ALUOp=1011, ZFWrt, type=pre-fetch(10) *


>> "and a, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and A on X bus. * 
	01100010, 00001011, 00010000, 00110000 * A_Out, A_Wrt, MDR_Y_Out, ALUOp=1011, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*
	
	
>> "and a, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* and with A *
	01100010, 00001011, 00010000, 00110000 * A_Wrt, MDR_Y_Out, A_Out, ALUOp=1011, ALUMode=1, ZF_Wrt, type=pre(10) *
	

>> "and [ad8], a"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr AND a *
	01100000, 00001011, 00010100, 00100000 * MDR_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALUOp=1011, ALUMode=1, ZF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *



>> "and b, a"
	00100000, 00100001, 00000000, 10001001 * A_Out, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	01100010, 00001011, 00000000, 11000010 * B_Out, BWrt, TDROut, ALUMode=1, ALUOp=1011, ZFWrt, type=pre-fetch(10) *


>> "and b, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and B on X bus. * 
	01100010, 00001011, 00010000, 11000000 * B_Out, B_Wrt, MDR_Y_Out, ALUOp=1011, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*
	
	
>> "and b, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* and with B *
	01100010, 00001011, 00010000, 11000000 * B_Wrt, MDR_Y_Out, B_Out, ALUOp=1011, ALUMode=1, ZF_Wrt, type=pre(10) *
	
>> "and [ad8], b"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr AND b *
	01100000, 00001011, 00010100, 10000000 * MDR_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALUOp=1011, ALUMode=1, ZF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "or a, b"
	00100000, 00100001, 00000000, 10001001 * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001011, 00000000, 00110010 * AOut, AWrt, TDROut, ALUMode=1, ALUOp=1110, ZFWrt, type=pre-fetch(10) *


>> "or a, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and A on X bus. * 
	11000010, 00001011, 00010000, 00110000 * A_Out, A_Wrt, MDR_Y_Out, ALUOp=1110, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*
	
	
>> "or a, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* or with A *
	11000010, 00001011, 00010000, 00110000 * A_Wrt, MDR_Y_Out, A_Out, ALUOp=1110, ALUMode=1, ZF_Wrt, type=pre(10) *
	
>> "or [ad8], a"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr OR a *
	11000000, 00001011, 00010100, 00100000 * MDR_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALUOp=1110, ALUMode=1, ZF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "or b, a"
	00100000, 00100001, 00000000, 10001001 * AOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001011, 00000000, 11000010 * BOut, BWrt, TDROut, ALUMode=1, ALUOp=1110, ZFWrt, type=pre-fetch(10) *


>> "or b imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and B on X bus. * 
	11000010, 00001011, 00010000, 11000000 * B_Out, B_Wrt, MDR_Y_Out, ALUOp=1110, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*
	
	
>> "or b, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* or with A *
	11000010, 00001011, 00010000, 11000000 * B_Wrt, MDR_Y_Out, B_Out, ALUOp=1110, ALUMode=1, ZF_Wrt, type=pre(10) *
	
>> "or [ad8], b"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr OR b *
	11000000, 00001011, 00010100, 10000000 * MDR_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALUOp=1110, ALUMode=1, ZF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "xor a, b"
	00100000, 00100001, 00000000, 10001001 * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001010, 00000000, 00110010 * AOut, AWrt, TDROut, ALUMode=1, ALUOp=0110, ZFWrt, type=pre-fetch(10) *


>> "xor a, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and A on X bus. * 
	11000010, 00001010, 00010000, 00110000 * A_Out, A_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*
	
	
>> "xor a, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* xor with A *
	11000010, 00001010, 00010000, 00110000 * A_Wrt, MDR_Y_Out, A_Out, ALUOp=0110, ALUMode=1, ZF_Wrt, type=pre(10) *
	
>> "xor [ad8], a"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr XOR a *
	11000000, 00001010, 00010100, 00100000 * MDR_Wrt, MDR_Y_Out, A_Out, MDR_In_Mux=0, ALUOp=0110, ALUMode=1, ZF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


>> "xor b, a"
	00100000, 00100001, 00000000, 10001001 * AOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001010, 00000000, 11000010 * BOut, BWrt, TDROut, ALUMode=1, ALUOp=0110, ZFWrt, type=pre-fetch(10) *


>> "xor b, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and B on X bus. * 
	11000010, 00001010, 00010000, 11000000 * B_Out, B_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*
	
	
>> "xor b, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* xor with B *
	11000010, 00001010, 00010000, 11000000 * B_Wrt, MDR_Y_Out, B_Out, ALUOp=0110, ALUMode=1, ZF_Wrt, type=pre(10) *
	
>> "xor [ad8], b"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- mdr XOR b *
	11000000, 00001010, 00010100, 10000000 * MDR_Wrt, MDR_Y_Out, B_Out, MDR_In_Mux=0, ALUOp=0110, ALUMode=1, ZF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *



*
1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt
*

>> "not a"
	 00000010, 00001010, 00000000, 00111000 * AOut, AWrt, IMMOut, IMM(0), ALUMode=1, ALUOp=0000, ZFWrt, type=pre-fetch(10) *

>> "not b"
	00000010, 00001010, 00000000, 11001000 * BOut, BWrt, IMMOut, IMM(0), ALUMode=1, ALUOp=0000, ZFWrt, type=pre-fetch(10) *
	
>> "not [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* mdr <-- [ad8] *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- not mdr *
	00000000, 00001010, 00001100, 00001000 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, MDR_In_Mux=0, ALUOp=0000, ALUMode=1, ZF_Wrt, type=seq(00) *
	* [ad8] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	

>> "not [b]"
	00100000, 00100001, 10000000, 10001000 * MAR_Wrt, B_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* mdr <-- [b] *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* mdr <-- not mdr *
	00000000, 00001010, 00001100, 00001000 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, MDR_In_Mux=0, ALUOp=0000, ALUMode=1, ZF_Wrt, type=seq(00) *
	* [b] <-- mdr *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	

>> "clc"
	00100010, 00110101, 00001000, 00001000 * CF_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, CarryOutInvert=1, type=pre-fetch(10) *


>> "stc"
	01000000, 00000011, 00000100, 00101000 * MDR_Wrt, IMM_Out, (A_Out), MDR_In_Mux=0, IMM_Val=0, ALU_Op=1010, ALU_Mode=1, type=00(seq) *
	11000010, 00000100, 00001000, 00001100 * CF_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=0110, ALU_Mode=0, Carry_In_Mux=00, type=pre(10) *


>> "clz"
	01000000, 00000011, 00000100, 00101000 * MDR_Wrt, IMM_Out, (A_Out), MDR_In_Mux=0, IMM_Val=0, ALU_Op=1010, ALU_Mode=1, type=00(seq) *
	00100010, 00101001, 00001000, 00001100 * ZF_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=pre(10) *


>> "stz"	
	01000000, 00000011, 00000100, 00101000 * MDR_Wrt, IMM_Out, (A_Out), MDR_In_Mux=0, IMM_Val=0, ALU_Op=1010, ALU_Mode=1, type=00(seq) *
	00100010, 00101001, 00001000, 00001000 * ZF_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, type=pre(10) *


>> "jmp ad8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *


>> "jmp [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU_Op=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM_Val=0, ALU_Op = 1001, ALU_Mode = 0, Carry_In_Mux=01, Next=pre-fetch(10)*	


>> "jmp b"
	00100010, 10100001, 00000000, 10001000 * B_Out, PC_Wrt, IMM_Out, IMM_Val=0, ALU_Op = 1001, ALU_Mode = 0, Carry_In_Mux=01, Next=pre-fetch(10) *	
	
>> "jmp [b]"
	00100000, 00100001, 10000000, 10001000 * B_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM_Val=0, ALU_Op = 1001, ALU_Mode = 0, Carry_In_Mux=01, Next=pre-fetch(10) *	


>> "jmp a"
	00100010, 10100001, 00000000, 00101000 * A_Out, PC_Wrt, IMM_Out, IMM_Val=0, ALU_Op = 1001, ALU_Mode = 0, Carry_In_Mux=01, Next=pre-fetch(10) *	
	
	
>> "jmp [a]"
	00100000, 00100001, 10000000, 00101000 * A_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM_Val=0, ALU_Op = 1001, ALU_Mode = 0, Carry_In_Mux=01, Next=pre-fetch(10) *


>> "jz ad8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000001, 00000000, 00000000, 00000000 * branch point. if ZF = 1 then execute next u. else jump to fetch. branch_code=0(ZF), type=branch(01)*
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *
	
	
>> "jz [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00000001, 00000000, 00000000, 00000000 * branch point. if ZF = 1 then execute next u. else jump to fetch. branch_code=0(ZF), type=branch(01)*
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *

>> "jz a"
	00000001, 00000000, 00000000, 00000000 * branch point. if ZF = 1 then execute next u. else jump to fetch. branch_code=0(ZF), type=branch(01)*
	00100010, 10100001, 00000000, 00101000 * A_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *

>> "jz b"
	00000001, 00000000, 00000000, 00000000 * branch point. if ZF = 1 then execute next u. else jump to fetch. branch_code=0(ZF), type=branch(01)*
	00100010, 10100001, 00000000, 10001000 * B_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *
	

>> "jz [b]"
	00000001, 00000000, 00000000, 00000000 * branch point. if ZF = 1 then execute next u. else jump to fetch. branch_code=0(ZF), type=branch(01)*
	00100000, 00100001, 10000000, 10001000 * B_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM_Val=0, ALU_Op = 1001, ALU_Mode = 0, Carry_In_Mux=01, Next=pre-fetch(10) *
	
	
>> "jz [a]"
	00000001, 00000000, 00000000, 00000000 * branch point. if ZF = 1 then execute next u. else jump to fetch. branch_code=0(ZF), type=branch(01)*
	00100000, 00100001, 10000000, 00101000 * A_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM_Val=0, ALU_Op = 1001, ALU_Mode = 0, Carry_In_Mux=01, Next=pre-fetch(10) *


>> "jc ad8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000101, 00000000, 00000000, 00000000 * branch point. if CF = 1 then execute next u. else jump to fetch. branch_code=1(CF), type=branch(01) *
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch)*
	
	
>> "jc [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00000101, 00000000, 00000000, 00000000 * branch point. if CF = 1 then execute next u. else jump to fetch. branch_code=1(CF), type=branch(01)*
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *

>> "jc a"
	00000101, 00000000, 00000000, 00000000 * branch point. if CF = 1 then execute next u. else jump to fetch. branch_code=1(CF), type=branch(01) *
	00100010, 10100001, 00000000, 00101000 * A_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch)*
	
>> "jc [a]"
	00000101, 00000000, 00000000, 00000000 * branch point. if CF = 1 then execute next u. else jump to fetch. branch_code=1(CF), type=branch(01) *	
	00100000, 00100001, 10000000, 00101000 * A_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM_Val=0, ALU_Op = 1001, ALU_Mode = 0, Carry_In_Mux=01, Next=pre-fetch(10) *

>> "jc b"
	00000101, 00000000, 00000000, 00000000 * branch point. if CF = 1 then execute next u. else jump to fetch. branch_code=1(CF), type=branch(01) *
	00100010, 10100001, 00000000, 10001000 * B_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch)*
	
>> "jc [b]"
	00000101, 00000000, 00000000, 00000000 * branch point. if CF = 1 then execute next u. else jump to fetch. branch_code=1(CF), type=branch(01) *	
	00100000, 00100001, 10000000, 10001000 * B_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM_Val=0, ALU_Op = 1001, ALU_Mode = 0, Carry_In_Mux=01, Next=pre-fetch(10) *


>> "cmp a, b"
	00100000, 00100001, 00000000, 10001001 * BOut, TDRWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001100, 00000000, 00100010 * AOut, TDROut, ALUMode=0, ALUOp=0110, CarryInMux=00, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *
	
	finish this also
>> "cmp [a], [b]"
	00100000, 00100001, 00000000, 10001001 * BOut, TDRWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001100, 00000000, 00100010 * AOut, TDROut, ALUMode=0, ALUOp=0110, CarryInMux=00, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *


>> "cmp a, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000  
	11000010, 00001100, 00010000, 00100000 * A_Out, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*
	
	
>> "cmp a, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* sub from A but don't save to A *
	11000010, 00001100, 00010000, 00100000 * MDR_Y_Out, A_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre(10) *
	
	
>> "cmp a, [b + imm8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10010000, 10000000 * B_Out, MDR_Y_Out, MAR_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	11000010, 00001100, 00010000, 00100000 * MDR_Y_Out, A_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre(10) *


>> "cmp a, [bp + imm8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* MDR to TDR (save imm8) *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* BP to MDR *
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + TDR --> MAR *
	00100000, 00100001, 10001000, 00000010 * MAR_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* [bp + imm8] to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* sub a, mdr *
	11000010, 00001100, 00010000, 00100000 * A_Out, MDR_Y_Out, ALU_Op=0110, ALU_Mode=0, CarryInMux=00, ZF_Wrt, CF_Wrt, type=10 *
	
>> "cmp a, [bp + b + imm8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* MDR to TDR (save imm8) *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* BP to MDR *
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + TDR --> MDR *
	00100000, 00100001, 00001100, 00000010 * MDR_Wrt, MDR_X_Out, TDR_Out, MDR_In_Mux=0(Z), ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* MDR + B --> MAR *
	00100000, 00100001, 10010000, 10000000 * MAR_Wrt, MDR_Y_Out, B_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* [bp + b + imm8] to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* sub a, mdr *
	11000010, 00001100, 00010000, 00100000 * A_Out, MDR_Y_Out, ALU_Op=0110, ALU_Mode=0, CarryInMux=00, ZF_Wrt, CF_Wrt, type=10 *

>> "cmp b, imm8"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 * Delay to avoid bus collision between PC and B on X bus. * 
	11000010, 00001100, 00010000, 10000000 * B_Out, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*
	
	
>> "cmp b, [ad8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	* read *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	* sub from B but don't save to B *
	11000010, 00001100, 00010000, 10000000 * MDR_Y_Out, B_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre(10) *
	
	
>> "cmp b, [a + imm8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10010000, 00100000 * A_Out, MDR_Y_Out, MAR_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	11000010, 00001100, 00010000, 10000000 * MDR_Y_Out, B_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre(10) *
	
	
>> "cmp b, [bp + imm8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* MDR to TDR (save imm8) *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* BP to MDR *
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + TDR --> MAR *
	00100000, 00100001, 10001000, 00000010 * MAR_Wrt, MDR_X_Out, TDR_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* [bp + imm8] to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* sub a, mdr *
	11000010, 00001100, 00010000, 10000000 * B_Out, MDR_Y_Out, ALU_Op=0110, ALU_Mode=0, CarryInMux=00, ZF_Wrt, CF_Wrt, type=10 *
	
	
>> "cmp b, [bp + a + imm8]"
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100 * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000
	* MDR to TDR (save imm8) *
	00100000, 00100001, 00001000, 00001001 * TDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* BP to MDR *
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR + TDR --> MDR *
	00100000, 00100001, 00001100, 00000010 * MDR_Wrt, MDR_X_Out, TDR_Out, MDR_In_Mux=0(Z), ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* MDR + A --> MAR *
	00100000, 00100001, 10010000, 00100000 * MAR_Wrt, MDR_Y_Out, A_Out, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, type=00 *
	* [bp + a + imm8] to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* sub a, mdr *
	11000010, 00001100, 00010000, 10000000 * B_Out, MDR_Y_Out, ALU_Op=0110, ALU_Mode=0, CarryInMux=00, ZF_Wrt, CF_Wrt, type=10 *
	
	
	

*
1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt
*

* pushes PC, jumps to AD8 *
>> "call ad8"
	 * push PC *
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	
	00000000, 00000000, 00000000, 00000000 
	* push PC + 1 *
	00100000, 00100001, 00000101, 00001100 * MDR_Wrt, PC_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
		
	* dec SP *
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* dec SP (MDR) and write to &SP *
	11000000, 00000000, 00001100, 00001100 * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=0110, ALU_Mode=0, Carry_In_Mux=00, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

	* jump to AD8 *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *
	
	
* pushes PC, jumps to [AD8] *
>> "call [ad8]"
	 * push PC *
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	
	00000000, 00000000, 00000000, 00000000 
	* push PC + 1 *
	00100000, 00100001, 00000101, 00001100 * MDR_Wrt, PC_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
		
	* dec SP *
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* dec SP (MDR) and write to &SP *
	11000000, 00000000, 00001100, 00001100 * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=0110, ALU_Mode=0, Carry_In_Mux=00, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	* jump to [ad8] *
	00100000, 00100001, 10000001, 00001000 * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *
	

* pushes PC, jumps to b *
>> "call b"
	* push PC *
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	
	00000000, 00000000, 00000000, 00000000 
	* push PC *
	00100000, 00100001, 00000101, 00001000 * MDR_Wrt, PC_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
		
	* dec SP *
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* dec SP (MDR) and write to &SP *
	11000000, 00000000, 00001100, 00001100 * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=0110, ALU_Mode=0, Carry_In_Mux=00, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

	* jump to B *
	00100010, 10100001, 00000000, 10001000 * B_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *
	
	
* pushes PC, jumps to b *
>> "call [b]"
	* push PC *
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	
	00000000, 00000000, 00000000, 00000000 
	* push PC *
	00100000, 00100001, 00000101, 00001000 * MDR_Wrt, PC_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
		
	* dec SP *
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* dec SP (MDR) and write to &SP *
	11000000, 00000000, 00001100, 00001100 * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=0110, ALU_Mode=0, Carry_In_Mux=00, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

	* jump to [b] *
	00100000, 00100001, 10000000, 10001000 * B_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *


* pop PC *
>> "ret"	
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 

	* here, MAR receives &SP; reading SP into MDR *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* inc SP for pop *
	00100000, 00100001, 00001100, 00001100 * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* write SP to &SP *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=seq(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	* SP to MAR and read *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	* [SP] to PC *
	00100010, 10100001, 00001000, 00001000 * MDR_X_Out, PC_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=pre-fetch(10) *
	


* 	
	also make mov bp, sp and move sp, bp instructions

push bp; move bp, sp 
	
	//bp to tdr
	mar <- &bp
	mdr <- bp
	tdr <- mdr
	// bp to [sp]
	mar <- &sp
	mdr <- sp
	mar <- mdr (mar = sp)
	mdr <- tdr
	[sp] <- mdr (save bp to [sp])
	// sp--
	mar <- &sp
	mdr <- sp
	mdr <- mdr - 1
	[&sp] <- mdr
	// tdr <- sp
	mar <- &sp
	mdr <- sp
	tdr <- mdr
	// bp <- sp
	mar <- &bp
	mdr <- tdr
	[&bp] <- mdr
	
*


make space for variables: newfrm 3 : creates 3 variables by decreasing sp!
* push bp, move bp, sp *
>> "newfrm"
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* MDR to TDR *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_M=0, CIM=01, next=00 *
	
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) * 
	00000000, 00000000, 00000000, 00000000 
	* finally, TDR to [SP] *
	01000000, 00000011, 00000100, 00100010 * MDR_Wrt, TDR_Out, (A_Out), MDR_In_Mux=0(Z), ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
	* dec SP; save SP to TDR *
	* now to dec SP and rewrite it to &SP *
		* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
		* here, MAR receives &SP; reading SP into MDR *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *	
		* subtract one from SP (MDR) and write to &SP (MAR) and TDR (to TDR in order to be moved to BP afterwards) *
	11000000, 00000000, 00001100, 00001101 * MDR_X_Out, MDR_Wrt, TDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=0110, ALU_Mode=0, Carry_In_Mux=00, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
	* saving TDR (updated SP) to &BP *
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* TDR to MDR *
	01000000, 00000011, 00000100, 00100010 * TDR_Out, MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	* MDR to &BP (saving SP to BP) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	
	
>> "endfrm"
	* pop bp *
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 

	* here, MAR receives &SP; reading SP into MDR *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* inc SP for pop *
	00100000, 00100001, 00001100, 00001100 * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=seq(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	* sp to mar, [sp] to mdr *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	* mdr to tdr *
	00100000, 00100001, 00001000, 00001001 * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=pre-fetch(10) *

	* saving [sp](in tdr) to bp *
	* loading 0x03 into MAR and reading &BP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 00001100, 00001100 * MDR_Wrt, MDR_In_Mux=0(Z), MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	* &BP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &BP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* write TDR to MDR *
	01000000, 00000011, 00000100, 00100010 * MDR_Wrt, TDR_Out, (A_Out), MDR_In_Mux=0(Z), ALU_Op=1010, ALU_Mode=1, type=00(seq) *
	* write MDR to &BP * 
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


* &SP is located at 0x02 *
>> "push a"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) * 
	00000000, 00000000, 00000000, 00000000 
	* finally, B to [SP] *
	00100000, 00100001, 00000100, 00101000 * MDR_Wrt, A_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

	* now to dec SP and rewrite it to &SP *
		* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 

		* here, MAR receives &SP; reading SP into MDR *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *	
		* subtract one from SP (MDR) and write to &SP (MAR) *
	11000000, 00000000, 00001100, 00001100 * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=0110, ALU_Mode=0, Carry_In_Mux=00, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

* &SP is located at 0x02 *
>> "push b"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* &SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	* SP to MDR *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *
	* SP to MAR *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) * 
	00000000, 00000000, 00000000, 00000000 
	* finally, B to [SP] *
	00100000, 00100001, 00000100, 10001000 * MDR_Wrt, B_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

	* now to dec SP and rewrite it to &SP *
		* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 

		* here, MAR receives &SP; reading SP into MDR *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 *	
		* subtract one from SP (MDR) and write to &SP (MAR) *
	11000000, 00000000, 00001100, 00001100 * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=0110, ALU_Mode=0, Carry_In_Mux=00, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *


* &SP is located at 0x02 *
>> "pop a"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 

	* here, MAR receives &SP; reading SP into MDR *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* inc SP for pop *
	00100000, 00100001, 00001100, 00001100 * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=seq(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	* sp to mar, [sp] to mdr *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	* mdr to a *
	00100010, 00100001, 00001000, 00011000 * MDR_X_Out, A_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=pre-fetch(10) *	

* &SP is located at 0x02 *
>> "pop b"
	* loading 0x02 into MAR and reading &SP into MDR *
	01000000, 00000011, 00000100, 00101100 * MDR_Wrt, MDR_In_Mux=0(Z), (A_Out), IMM_Out, IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00000000, 00000000 
	00100000, 00100001, 10001000, 00001100 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 * 
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 

	* here, MAR receives &SP; reading SP into MDR *
	00100000, 00100001, 10001000, 00001000 * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	* inc SP for pop *
	00100000, 00100001, 00001100, 00001100 * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=00(+1) ** open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000 * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000 * MDR_DB_Out, type=seq(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	00100000, 00100001, 10001000, 00001000 * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 00000000, 00000000 * RD, next=00 *
	00001000, 00000000, 01000100, 00000000 * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100010, 00100001, 00001000, 01001000 * MDR_X_Out, B_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=pre-fetch(10) *	

*
1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt
*
	

>> "nop"
	00000010, 00000000, 00000000, 00000000 * NOP: Total of 5 clock cycles including the previous Fetch. *

