* 
  Microcode for all ROMS
  Least significant bits on the right
  Types of micro-instruction:         seq	 = 00 (next is sequential)
						branch = 01 (next depends on branch conditions)
					   pre-fetch = 10 (next is fetch)
					  post-fetch = 11 (next given by IR)

CarryInMux:	00 :   0		used for SUB
		01 :   1		used for ADD
		10 :  CF		used for SBB
		11 : ~CF		used for ADC


CONTROL BITS
	HIGH-------------------------------------------------------------------------------LOW

ROM1: ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
ROM2: PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
ROM3: MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
ROM4:	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt

*

* FETCH *
*	ROM 1     ROM 2     ROM 3     ROM 4     *
0x00: 00000000, 00000000, 00000000, 00000000, * During this cycle, nothing is output onto the bus, in order no to create shorts. 
								Because the previous u-instructions might have been outputting data onto the buses and if PC outputs right after they might collide. *
	00100000, 00100001, 10000001, 00001000, * PC_Out, IMMVal=0, IMMOut, ALU=1001, ALUMode=0, CarryInMux=01, MAR_Wrt, type=seq(00) *
	00001000, 00000000, 00000010, 00000000, * RD, IR_Wrt, type=seq (00)*
	00100000, 10100001, 00000001, 00001100, * PC_Out, PC_Wrt, ALU=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, type= +1(00)*
	00000011, 00000000, 00000000, 00000000; * Delay to avoid bus collision between PC and next instruction on X bus. post-fetch(11)* 		

* MOV A, B *
0x01: 00100010, 00100001, 00000000, 10011000; * BOut, AWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux=01, type=pre-fetch(10) *

* MOV A, IMM8 *                                                                                                                 
0x02: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux=01, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and MDR on X bus. * 
	00100010, 00100001, 00001000, 00011000; * A_Wrt, MDR_X_Out, IMM_Out=1, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10)*

* MOV A, [AD8] *
0x03: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM_Val=0, CarryInMux=01, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and MDR on X bus. * 
	00100000, 00100001, 10001000, 00001000, * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 00011000; * A_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10) *

* MOV [AD8], A *
0x04: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, 
	00100000, 00100001, 10001000, 00001000, * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and MDR on X bus. * 
	00100000, 00100001, 00000100, 00101000, * A_Out, MDRIn_Mux=0, MDR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000; * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *	

* MOV A, [B + SIGNED8] - 2 BYTE INSTRUCTION *
0x05: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000,
	00100000, 00100001, 10010000, 10001000, * B_Out, MDR_Y_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 00011000; * A_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10) *	
	
	
* MOV [B + SIGNED8], A - 2 BYTE INSTRUCTION *
0x06: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD, ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000,
	00100000, 00100001, 10010000, 10001000, * B_Out, MDR_Y_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000, 
	00100000, 00100001, 00000100, 00101000, * A_Out, MDRIn_Mux=0, MDR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000; * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *



*

1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt

*

* MOV B, A *
0x06: 00100010, 00100001, 00000000, 01101000; * AOut, BWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, type=pre-fetch(10) *

* MOV B, IMM8 *
0x07: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 ** Send PC to MAR *		    
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 ** read byte from mem and write to mdr *			    
	00100000, 10100001, 00000001, 00001100, * PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 ** increase PC by 1. *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and MDR on X bus. * 
	00100010, 00100001, 00001000, 01001000; * B_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10)** save result to B: *
							    
* MOV B, [AD8] *
0x08: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and MDR on X bus. * 
	00100000, 00100001, 10001000, 00001000, * MAR_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, next=00*
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 00100001, 00001000, 01001000; * B_Wrt, MDR_X_Out, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux=01, type=pre-fetch(10) *

* MOV [AD8], B *
0x09: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and MDR on X bus. * 
	00100000, 00100001, 10001000, 00001000, * MAR_Wrt, MDR_X_Out, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between B and MDR on X bus. * 
	00100000, 00100001, 00000100, 10001000, * B_Out, MDRIn_Mux=0, MDR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, type=00 *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000; * MDR_DB_Out, type=10(pre-fetch) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

*

1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt

*

* INC A *
0x0B:	00100010, 00111101, 00000000, 00111100; * AOut, AWrt, IMM_Out, IMM_Val=1, ALUMode=0, ALUOp=1001, CarryInMux=01, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *

* INC B *
0x0C:	00100010, 00111101, 00000000, 11001100; * BOut, BWrt, IMM_Out, IMM_Val=1, ALUMode=0, ALUOp=1001, CarryInMux=01, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *

* DEC A *
0x0D:	11000010, 00001100, 00000000, 00111100; * AOut, AWrt, IMM_Out, IMM_Val=1, ALUMode=0, ALUOp=0110, CarryInMux=00, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *

* DEC B *
0x0E:	11000010, 00001100, 00000000, 11001100; * BOut, BWrt, IMM_Out, IMM_Val=1, ALUMode=0, ALUOp=0110, CarryInMux=00, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *


* ADD A, B *
0x0F: 00100000, 00100001, 00000000, 10001001, * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 00111101, 00000000, 00110010; * AOut, AWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *

* ADD A, IMM8 *
0x10: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and A on X bus. * 
	00100010, 00111101, 00010000, 00110000; * A_Out, A_Wrt, MDR_Y_Out, ALUOp=1001, ALUMode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*

* ADD B, A *
0x11: 00100000, 00100001, 00000000, 00101001, * AOut, TDRWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 00111101, 00000000, 11000010; * BOut, BWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *

* ADD B, IMM8 *
0x12: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and B on X bus. * 
	00100010, 00111101, 00010000, 11000000; * B_Out, B_Wrt, MDR_Y_Out, ALUOp=1001, ALUMode=0, CarryInMux=01, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*



* ADC A, B *
0x13: 00100000, 00100001, 00000000, 10001001, * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 01111101, 00000000, 00110010; * AOut, AWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux=11, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *

* ADC A, IMM8 *
0x14: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and A on X bus. * 
	00100010, 01111101, 00010000, 00110000; * A_Out, A_Wrt, MDR_Y_Out, ALUOp=1001, ALUMode=0, CarryInMux=11, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*

* ADC B, A *
0x15: 00100000, 00100001, 00000000, 00101001, * AOut, TDRWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	00100010, 01111101, 00000000, 11000010; * BOut, BWrt, TDROut, ALUMode=0, ALUOp=1001, CarryInMux=11, CarryOutInvert=1, ZFWrt, CFWrt, type=pre-fetch(10) *

* ADC B, IMM8 *
0x16: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and B on X bus. * 
	00100010, 01111101, 00010000, 11000000; * B_Out, B_Wrt, MDR_Y_Out, ALUOp=1001, ALUMode=0, CarryInMux=11, CarryOutInvert=1, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*



* SUB A, B *
0x17: 00100000, 00100001, 00000000, 10001001, * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001100, 00000000, 00110010; * AOut, AWrt, TDROut, ALUMode=0, ALUOp=0110, CarryInMux1=0, CarryInMux0=0, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *

* SUB A, IMM8 *
0x18: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and A on X bus. * 
	11000010, 00001100, 00010000, 00110000; * A_Out, A_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*

* SUB B, A *
0x19: 00100000, 00100001, 00000000, 00001001, * AOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001100, 00000000, 11000010; * BOut, BWrt, TDROut, ALUMode=0, ALUOp=0110, CarryInMux1=0, CarryInMux0=0, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *

* SUB B, IMM8 *
0x1A: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and B on X bus. * 
	11000010, 00001100, 00010000, 11000000; * B_Out, B_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*



* SBB A, B *
0x1B: 00100000, 00100001, 00000000, 10001001, * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 01001100, 00000000, 00110010; * AOut, AWrt, TDROut, ALUMode=0, ALUOp=0110, CarryInMux=10, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *

* SBB A, IMM8 *
0x1C: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and A on X bus. * 
	11000010, 01001100, 00010000, 00110000; * A_Out, A_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=10, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*

* SBB B, A *
0x1D: 00100000, 00100001, 00000000, 00001001, * AOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 01001100, 00000000, 11000010; * BOut, BWrt, TDROut, ALUMode=0, ALUOp=0110, CarryInMux=10, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *

* SBB B, IMM8 *
0x1E: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and B on X bus. * 
	11000010, 01001100, 00010000, 11000000; * B_Out, B_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=10, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*

*
1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt
*

* AND A, B *
0x1F: 00100000, 00100001, 00000000, 10001001, * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	01100010, 00001011, 00000000, 00110010; * AOut, AWrt, TDROut, ALUMode=1, ALUOp=1011, ZFWrt, type=pre-fetch(10) *

* AND A, IMM8 *
0x20: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and A on X bus. * 
	01100010, 00001011, 00010000, 00110000; * A_Out, A_Wrt, MDR_Y_Out, ALUOp=1011, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*

* AND B, A *
0x21: 00100000, 00100001, 00000000, 10001001, * A_Out, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	01100010, 00001011, 00000000, 11000010; * B_Out, BWrt, TDROut, ALUMode=1, ALUOp=1011, ZFWrt, type=pre-fetch(10) *

* AND B, IMM8 *
0x22: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and B on X bus. * 
	01100010, 00001011, 00010000, 11000000; * B_Out, B_Wrt, MDR_Y_Out, ALUOp=1011, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*

* OR A, B *
0x23: 00100000, 00100001, 00000000, 10001001, * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001011, 00000000, 00110010; * AOut, AWrt, TDROut, ALUMode=1, ALUOp=1110, ZFWrt, type=pre-fetch(10) *

* OR A, IMM8 *
0x24: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and A on X bus. * 
	11000010, 00001011, 00010000, 00110000; * A_Out, A_Wrt, MDR_Y_Out, ALUOp=1110, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*

* OR B, A *
0x25: 00100000, 00100001, 00000000, 10001001, * AOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001011, 00000000, 11000010; * BOut, BWrt, TDROut, ALUMode=1, ALUOp=1110, ZFWrt, type=pre-fetch(10) *

* OR B, IMM8 *
0x26: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and B on X bus. * 
	11000010, 00001011, 00010000, 11000000; * B_Out, B_Wrt, MDR_Y_Out, ALUOp=1110, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*


* XOR A, B *
0x27: 00100000, 00100001, 00000000, 10001001, * BOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001010, 00000000, 00110010; * AOut, AWrt, TDROut, ALUMode=1, ALUOp=0110, ZFWrt, type=pre-fetch(10) *

* XOR A, IMM8 *
0x28: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and A on X bus. * 
	11000010, 00001010, 00010000, 00110000; * A_Out, A_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*

* XOR B, A *
0x29: 00100000, 00100001, 00000000, 10001001, * AOut, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, TDRWrt, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001010, 00000000, 11000010; * BOut, BWrt, TDROut, ALUMode=1, ALUOp=0110, ZFWrt, type=pre-fetch(10) *

* XOR B, IMM8 *
0x2A: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALUOp=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and B on X bus. * 
	11000010, 00001010, 00010000, 11000000; * B_Out, B_Wrt, MDR_Y_Out, ALUOp=0110, ALUMode=1, ZF_Wrt, type=pre-fetch(10)*



*
1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt
*

* NOT A *
0x2B: 00000010, 00001010, 00000000, 00111000; * AOut, AWrt, IMMOut, IMM(0), ALUMode=1, ALUOp=0000, ZFWrt, type=pre-fetch(10) *
	

* NOT B *
0x2C: 00000010, 00001010, 00000000, 11001000; * BOut, BWrt, IMMOut, IMM(0), ALUMode=1, ALUOp=0000, ZFWrt, type=pre-fetch(10) *
	

* JMP AD8 *
0x2D: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 10100001, 00001000, 00001000; * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *

* JZ AD8 *
0x2E: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000001, 00000000, 00000000, 00000000, * branch point. if ZF = 1 then execute next u. else jump to fetch. branch_code=0(ZF), type=branch(01)*
	00100010, 10100001, 00001000, 00001000; * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *

* JC AD8 *
0x2F: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000101, 00000000, 00000000, 00000000, * branch point. if CF = 1 then execute next u. else jump to fetch. branch_code=1(CF), type=branch(01) *
	00100010, 10100001, 00001000, 00001000; * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch)*

* CMP A, B *
0x30: 00100000, 00100001, 00000000, 10001001, * BOut, TDRWrt, IMMOut, IMM(0), ALUMode=0, ALUOp=1001, CarryInMux1=0, CarryInMux0=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between A and B on X bus. * 
	11000010, 00001100, 00000000, 00100010; * AOut, TDROut, ALUMode=0, ALUOp=0110, CarryInMux=00, CarryOutInvert=0, ZFWrt, CFWrt, type=pre-fetch(10) *

* CMP A, IMM8 *
0x31: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and A on X bus. * 
	11000010, 00001100, 00010000, 00100000; * A_Out, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*

* CMP B, IMM8*
0x32: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU=ADD,ALUMode=L, CarryInMux1=0, CarryInMux0=1, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, * Delay to avoid bus collision between PC and B on X bus. * 
	11000010, 00001100, 00010000, 10000000; * B_Out, MDR_Y_Out, ALUOp=0110, ALUMode=0, CarryInMux=00, CarryOutInvert=0, ZF_Wrt, CF_Wrt, type=pre-fetch(10)*

*
1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt
*

* CALL AD8 : [SP] <- PC, [SP+1] <- BP, BP <- SP *
0x33: * increment PC past AD8 *
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU_Op=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 *
	
	* push PC *
	01000000, 00000011, 10000000, 00101000, * MAR_Wrt, IMM_Out, (A_Out) IMM_Val=0, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	00100000, 00100001, 10001000, 00001000, * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00000000, 00000000, 
	00100000, 00100001, 00000101, 00001000, * MDR_Wrt, PC_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
		* inc SP *
	01000000, 00000011, 10000000, 00101000, * MAR_Wrt, IMM_Out, (A_Out), IMM_Val=0, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	00100000, 00100001, 00001100, 00001100, * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

	* push BP *
		* save BP to TDR *
	01000000, 00000011, 10000000, 00101100, * MAR_Wrt, IMM_Out, (A_Out), IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	00100000, 00100001, 00001000, 00001001, * MDR_X_Out, TDR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *

		* move SP to MAR *
	01000000, 00000011, 10000000, 00101000, * MAR_Wrt, IMM_Out, (A_Out) IMM_Val=0, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	00100000, 00100001, 10001000, 00001000, * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00000000, 00000000, 
		* push BP *
	01000000, 00000011, 00000100, 00100010, * MDR_Wrt, TDR_Out, (A_Out), MDR_In_Mux=0(Z), ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
		* inc SP *
	01000000, 00000011, 10000000, 00101000, * MAR_Wrt, IMM_Out, (A_Out), IMM_Val=0, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	00100000, 00100001, 00001100, 00001100, * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000; * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

	* mov bp, sp *
	* MDR has SP *
	01000000, 00000011, 10000000, 00101100, * MAR_Wrt, IMM_Out, (A_Out), IMM_Val=1, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000; * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

	

	//////////////
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU_Op=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, 
* push *
	
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 *
	00100000, 00100001, 10001000, 00001000, * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00000000, 00000000, 
	00100000, 00100001, 00000101, 00001000, * MDR_Wrt, PC_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	01000000, 00000011, 10000000, 00100010, * MAR_Wrt, TDR_Out, (A_Out), ALU_Op=1010, ALU_Mode=1, next=seq(00)*
	00001000, 00000000, 01000100, 00000000, * RD, MDR_Wrt, MDRIn_Mux=1(DB), next=00 * 
	11000000, 00000000, 00001100, 00001100, * MDR_X_Out, MDR_Wrt, IMM_Out, IMM_Val=1, ALU_Op=0110, ALU_Mode=0, Carry_In_Mux=00, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	11000000, 10000000, 00000001, 00001100, * PC-1: PC_Out, PC_Wrt, ALU_Op=0110, ALUMode=0, CarryInMux=00, IMM_Out, IMMVal=1, next=00 *
* jump *
	00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM(0), CarryInMux1=0, CarryInMux0=1, ALUOp=1001, ALUMode=0, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1, MDR_Wrt, next=00 *
	00100010, 10100001, 00001000, 00001000; * MDR_X_Out, PC_Wrt, IMM_Out, IMM(0), ALUOp=1001, ALUMode=0, CarryInMux1=0, CarryInMux0=1, type=10(pre_fetch) *
	

* RET STK8 - STK8 holds the address of the stack, used to retrieve PC *
0x34: 

* JMP [AD8] - Jumps to address located at AD8 *
0x34: 00100000, 00100001, 10000001, 00001000, * PC_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALUOp=1001, ALUMode=0, CarryInMux=01, Next=00 *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100000, 10100001, 00000001, 00001100, * PC+1: PC_Out, PC_Wrt, ALU_Op=1001, ALUMode=0, CarryInMux=01, IMM_Out, IMMVal=1, next=00 *
	00000000, 00000000, 00000000, 00000000, 
	00100000, 00100001, 10001000, 00001000, * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100010, 10100001, 00001000, 00001000; * MDR_X_Out, PC_Wrt, IMM_Out, IMM_Val=0, ALU_Op = 1001, ALU_Mode = 0, Carry_In_Mux=01, Next=pre-fetch(10)*

* PUSH A - SP is located at 0x00 *
0x35:
 	01000000, 00000011, 10000000, 00101000, * MAR_Wrt, IMM_Out, (A_Out) IMM_Val=0, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	00100000, 00100001, 10001000, 00001000, * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00000000, 00000000, 
	00100000, 00100001, 00000100, 00101000, * MDR_Wrt, A_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
 	01000000, 00000011, 10000000, 00101000, * MAR_Wrt, IMM_Out, (A_Out), IMM_Val=0, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	00100000, 00100001, 00001100, 00001100, * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000; * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

* PUSH B - SP is located at 0x00 *
0x35:
 	01000000, 00000011, 10000000, 00101000, * MAR_Wrt, IMM_Out, (A_Out) IMM_Val=0, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	00100000, 00100001, 10001000, 00001000, * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00000000, 00000000, 
	00100000, 00100001, 00000100, 10001000, * MDR_Wrt, B_Out, MDR_In_Mux=0(Z), IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, CarryInMux=01, next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
 	01000000, 00000011, 10000000, 00101000, * MAR_Wrt, IMM_Out, (A_Out), IMM_Val=0, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	00100000, 00100001, 00001100, 00001100, * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000010, 00000000, 00100000, 00000000; * MDR_DB_Out, type=00(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *

* POP A - SP is located at 0x00 *
0x36: 01000000, 00000011, 10000000, 00101000, * MAR_Wrt, IMM_Out, (A_Out) IMM_Val=0, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	11000000, 00000000, 00001100, 00001100, * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=0110, ALU_Mode=0, Carry_In_Mux=00, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=seq(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	00100000, 00100001, 10001000, 00001000, * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100010, 00100001, 00001000, 00011000; * MDR_X_Out, A_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=pre-fetch(10) *

* POP B - SP is located at 0x00 *
0x36: 01000000, 00000011, 10000000, 00101000, * MAR_Wrt, IMM_Out, (A_Out) IMM_Val=0, ALU_Op=1010, ALU_Mode=1, next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * MDR_Wrt, RD, MDRIn_Mux=1(DB), next=00 * 
	11000000, 00000000, 00001100, 00001100, * MDR_X_Out, MDR_Wrt, MDR_In_Mux=0, IMM_Out, IMM_Val=1, ALU_Op=0110, ALU_Mode=0, Carry_In_Mux=00, Next=seq(00) *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=00(+1) * open MDR to DB one cycle before WR goes low *
	00010000, 00000000, 00100000, 00000000, * WR, MDR_DB_Out, type=00(+1) * * WR goes low; MDR_DB still open *
	00000000, 00000000, 00100000, 00000000, * MDR_DB_Out, type=seq(00) * * WR goes inactive, but MDR_DB still needs to be open for data to stay stable. *
	00100000, 00100001, 10001000, 00001000, * MDR_X_Out, MAR_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=seq(00) *
	00001000, 00000000, 01000100, 00000000, * RD, MDRIn_Mux=1(DB), MDR_Wrt, next=00 * 
	00100010, 00100001, 00001000, 01001000; * MDR_X_Out, B_Wrt, IMM_Out, IMM_Val=0, ALU_Op=1001, ALU_Mode=0, Carry_In_Mux=01, Next=pre-fetch(10) *	
	

*
1 	ALU_Op2, ALU_Op1, ALU_Op0, WR, RD, branch_code, type1, type0
2 	PC_Wrt, CarryIn_Mux1, CarryIn_Mux0, CarryOut_Invert, ZF_Wrt, CF_Wrt, ALU_Mode, ALU_Op3
3 	MAR_Wrt, MDRIn_Mux, MDR_DB_Out, MDR_Y_Out, MDR_X_Out, MDR_Wrt, IR_Wrt, PC_Out
4	B_Out, B_Wrt, A_Out, A_Wrt, IMM_Out, IMM_Val, TDR_Out, TDR_Wrt
*

* NOP *
0x37: 00000010, 00000000, 00000000, 00000000; * NOP: Total of 5 clock cycles including the previous Fetch. *

